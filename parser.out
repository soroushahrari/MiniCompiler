Grammar:

Rule 0     S' -> block
Rule 1     block -> <empty>
Rule 2     block -> statements
Rule 3     statements -> statements statement
Rule 4     statements -> statement
Rule 5     statement -> while_statement
Rule 6     statement -> if_statement
Rule 7     statement -> assign_statement
Rule 8     statement -> var_declaration
Rule 9     if_statement -> IF ( expr ) { block }
Rule 10    if_statement -> IF ( expr ) { block } ELSE { block }
Rule 11    while_statement -> WHILE expr { block }
Rule 12    var_declaration -> TYPE IDENTIFIER ;
Rule 13    var_declaration -> TYPE IDENTIFIER ASSIGN expr ;
Rule 14    assign_statement -> IDENTIFIER ASSIGN expr ;
Rule 15    expr -> literal
Rule 16    expr -> IDENTIFIER
Rule 17    expr -> ( expr )
Rule 18    expr -> expr OR expr
Rule 19    expr -> expr AND expr
Rule 20    expr -> expr NEQUAL expr  [precedence=nonassoc, level=1]
Rule 21    expr -> expr EQUAL expr  [precedence=nonassoc, level=1]
Rule 22    expr -> expr GEQUAL expr  [precedence=nonassoc, level=1]
Rule 23    expr -> expr GREATERT expr  [precedence=nonassoc, level=1]
Rule 24    expr -> expr LEQUAL expr  [precedence=nonassoc, level=1]
Rule 25    expr -> expr LESST expr  [precedence=nonassoc, level=1]
Rule 26    expr -> expr DIVIDE expr  [precedence=left, level=3]
Rule 27    expr -> expr TIMES expr  [precedence=left, level=3]
Rule 28    expr -> expr MINUS expr  [precedence=left, level=2]
Rule 29    expr -> expr PLUS expr  [precedence=left, level=2]
Rule 30    literal -> BOOLEAN
Rule 31    literal -> STRING
Rule 32    literal -> FLOAT
Rule 33    literal -> INTEGER

Unused terminals:

    FOR
    SWITCH
    NOT
    CASE

Terminals, with rules where they appear:

(                    : 9 10 17
)                    : 9 10 17
;                    : 12 13 14
AND                  : 19
ASSIGN               : 13 14
BOOLEAN              : 30
CASE                 : 
DIVIDE               : 26
ELSE                 : 10
EQUAL                : 21
FLOAT                : 32
FOR                  : 
GEQUAL               : 22
GREATERT             : 23
IDENTIFIER           : 12 13 14 16
IF                   : 9 10
INTEGER              : 33
LEQUAL               : 24
LESST                : 25
MINUS                : 28
NEQUAL               : 20
NOT                  : 
OR                   : 18
PLUS                 : 29
STRING               : 31
SWITCH               : 
TIMES                : 27
TYPE                 : 12 13
WHILE                : 11
error                : 
{                    : 9 10 10 11
}                    : 9 10 10 11

Nonterminals, with rules where they appear:

assign_statement     : 7
block                : 9 10 10 11 0
expr                 : 9 10 11 13 14 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29
if_statement         : 6
literal              : 15
statement            : 3 4
statements           : 2 3
var_declaration      : 8
while_statement      : 5


state 0

    (0) S' -> . block
    (1) block -> .
    (2) block -> . statements
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . assign_statement
    (8) statement -> . var_declaration
    (11) while_statement -> . WHILE expr { block }
    (9) if_statement -> . IF ( expr ) { block }
    (10) if_statement -> . IF ( expr ) { block } ELSE { block }
    (14) assign_statement -> . IDENTIFIER ASSIGN expr ;
    (12) var_declaration -> . TYPE IDENTIFIER ;
    (13) var_declaration -> . TYPE IDENTIFIER ASSIGN expr ;
    $end            reduce using rule 1 (block -> .)
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    TYPE            shift and go to state 11

    block                          shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    while_statement                shift and go to state 4
    if_statement                   shift and go to state 5
    assign_statement               shift and go to state 6
    var_declaration                shift and go to state 7

state 1

    (0) S' -> block .


state 2

    (2) block -> statements .
    (3) statements -> statements . statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . assign_statement
    (8) statement -> . var_declaration
    (11) while_statement -> . WHILE expr { block }
    (9) if_statement -> . IF ( expr ) { block }
    (10) if_statement -> . IF ( expr ) { block } ELSE { block }
    (14) assign_statement -> . IDENTIFIER ASSIGN expr ;
    (12) var_declaration -> . TYPE IDENTIFIER ;
    (13) var_declaration -> . TYPE IDENTIFIER ASSIGN expr ;
    $end            reduce using rule 2 (block -> statements .)
    }               reduce using rule 2 (block -> statements .)
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    TYPE            shift and go to state 11

    statement                      shift and go to state 12
    while_statement                shift and go to state 4
    if_statement                   shift and go to state 5
    assign_statement               shift and go to state 6
    var_declaration                shift and go to state 7

state 3

    (4) statements -> statement .
    WHILE           reduce using rule 4 (statements -> statement .)
    IF              reduce using rule 4 (statements -> statement .)
    IDENTIFIER      reduce using rule 4 (statements -> statement .)
    TYPE            reduce using rule 4 (statements -> statement .)
    $end            reduce using rule 4 (statements -> statement .)
    }               reduce using rule 4 (statements -> statement .)


state 4

    (5) statement -> while_statement .
    WHILE           reduce using rule 5 (statement -> while_statement .)
    IF              reduce using rule 5 (statement -> while_statement .)
    IDENTIFIER      reduce using rule 5 (statement -> while_statement .)
    TYPE            reduce using rule 5 (statement -> while_statement .)
    $end            reduce using rule 5 (statement -> while_statement .)
    }               reduce using rule 5 (statement -> while_statement .)


state 5

    (6) statement -> if_statement .
    WHILE           reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 6 (statement -> if_statement .)
    TYPE            reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    }               reduce using rule 6 (statement -> if_statement .)


state 6

    (7) statement -> assign_statement .
    WHILE           reduce using rule 7 (statement -> assign_statement .)
    IF              reduce using rule 7 (statement -> assign_statement .)
    IDENTIFIER      reduce using rule 7 (statement -> assign_statement .)
    TYPE            reduce using rule 7 (statement -> assign_statement .)
    $end            reduce using rule 7 (statement -> assign_statement .)
    }               reduce using rule 7 (statement -> assign_statement .)


state 7

    (8) statement -> var_declaration .
    WHILE           reduce using rule 8 (statement -> var_declaration .)
    IF              reduce using rule 8 (statement -> var_declaration .)
    IDENTIFIER      reduce using rule 8 (statement -> var_declaration .)
    TYPE            reduce using rule 8 (statement -> var_declaration .)
    $end            reduce using rule 8 (statement -> var_declaration .)
    }               reduce using rule 8 (statement -> var_declaration .)


state 8

    (11) while_statement -> WHILE . expr { block }
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 13
    literal                        shift and go to state 14

state 9

    (9) if_statement -> IF . ( expr ) { block }
    (10) if_statement -> IF . ( expr ) { block } ELSE { block }
    (               shift and go to state 21


state 10

    (14) assign_statement -> IDENTIFIER . ASSIGN expr ;
    ASSIGN          shift and go to state 22


state 11

    (12) var_declaration -> TYPE . IDENTIFIER ;
    (13) var_declaration -> TYPE . IDENTIFIER ASSIGN expr ;
    IDENTIFIER      shift and go to state 23


state 12

    (3) statements -> statements statement .
    WHILE           reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statements statement .)
    TYPE            reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 13

    (11) while_statement -> WHILE expr . { block }
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               shift and go to state 24
    OR              shift and go to state 25
    AND             shift and go to state 26
    NEQUAL          shift and go to state 27
    EQUAL           shift and go to state 28
    GEQUAL          shift and go to state 29
    GREATERT        shift and go to state 30
    LEQUAL          shift and go to state 31
    LESST           shift and go to state 32
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 14

    (15) expr -> literal .
    {               reduce using rule 15 (expr -> literal .)
    OR              reduce using rule 15 (expr -> literal .)
    AND             reduce using rule 15 (expr -> literal .)
    NEQUAL          reduce using rule 15 (expr -> literal .)
    EQUAL           reduce using rule 15 (expr -> literal .)
    GEQUAL          reduce using rule 15 (expr -> literal .)
    GREATERT        reduce using rule 15 (expr -> literal .)
    LEQUAL          reduce using rule 15 (expr -> literal .)
    LESST           reduce using rule 15 (expr -> literal .)
    DIVIDE          reduce using rule 15 (expr -> literal .)
    TIMES           reduce using rule 15 (expr -> literal .)
    MINUS           reduce using rule 15 (expr -> literal .)
    PLUS            reduce using rule 15 (expr -> literal .)
    )               reduce using rule 15 (expr -> literal .)
    ;               reduce using rule 15 (expr -> literal .)


state 15

    (16) expr -> IDENTIFIER .
    {               reduce using rule 16 (expr -> IDENTIFIER .)
    OR              reduce using rule 16 (expr -> IDENTIFIER .)
    AND             reduce using rule 16 (expr -> IDENTIFIER .)
    NEQUAL          reduce using rule 16 (expr -> IDENTIFIER .)
    EQUAL           reduce using rule 16 (expr -> IDENTIFIER .)
    GEQUAL          reduce using rule 16 (expr -> IDENTIFIER .)
    GREATERT        reduce using rule 16 (expr -> IDENTIFIER .)
    LEQUAL          reduce using rule 16 (expr -> IDENTIFIER .)
    LESST           reduce using rule 16 (expr -> IDENTIFIER .)
    DIVIDE          reduce using rule 16 (expr -> IDENTIFIER .)
    TIMES           reduce using rule 16 (expr -> IDENTIFIER .)
    MINUS           reduce using rule 16 (expr -> IDENTIFIER .)
    PLUS            reduce using rule 16 (expr -> IDENTIFIER .)
    )               reduce using rule 16 (expr -> IDENTIFIER .)
    ;               reduce using rule 16 (expr -> IDENTIFIER .)


state 16

    (17) expr -> ( . expr )
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 37
    literal                        shift and go to state 14

state 17

    (30) literal -> BOOLEAN .
    {               reduce using rule 30 (literal -> BOOLEAN .)
    OR              reduce using rule 30 (literal -> BOOLEAN .)
    AND             reduce using rule 30 (literal -> BOOLEAN .)
    NEQUAL          reduce using rule 30 (literal -> BOOLEAN .)
    EQUAL           reduce using rule 30 (literal -> BOOLEAN .)
    GEQUAL          reduce using rule 30 (literal -> BOOLEAN .)
    GREATERT        reduce using rule 30 (literal -> BOOLEAN .)
    LEQUAL          reduce using rule 30 (literal -> BOOLEAN .)
    LESST           reduce using rule 30 (literal -> BOOLEAN .)
    DIVIDE          reduce using rule 30 (literal -> BOOLEAN .)
    TIMES           reduce using rule 30 (literal -> BOOLEAN .)
    MINUS           reduce using rule 30 (literal -> BOOLEAN .)
    PLUS            reduce using rule 30 (literal -> BOOLEAN .)
    )               reduce using rule 30 (literal -> BOOLEAN .)
    ;               reduce using rule 30 (literal -> BOOLEAN .)


state 18

    (31) literal -> STRING .
    {               reduce using rule 31 (literal -> STRING .)
    OR              reduce using rule 31 (literal -> STRING .)
    AND             reduce using rule 31 (literal -> STRING .)
    NEQUAL          reduce using rule 31 (literal -> STRING .)
    EQUAL           reduce using rule 31 (literal -> STRING .)
    GEQUAL          reduce using rule 31 (literal -> STRING .)
    GREATERT        reduce using rule 31 (literal -> STRING .)
    LEQUAL          reduce using rule 31 (literal -> STRING .)
    LESST           reduce using rule 31 (literal -> STRING .)
    DIVIDE          reduce using rule 31 (literal -> STRING .)
    TIMES           reduce using rule 31 (literal -> STRING .)
    MINUS           reduce using rule 31 (literal -> STRING .)
    PLUS            reduce using rule 31 (literal -> STRING .)
    )               reduce using rule 31 (literal -> STRING .)
    ;               reduce using rule 31 (literal -> STRING .)


state 19

    (32) literal -> FLOAT .
    {               reduce using rule 32 (literal -> FLOAT .)
    OR              reduce using rule 32 (literal -> FLOAT .)
    AND             reduce using rule 32 (literal -> FLOAT .)
    NEQUAL          reduce using rule 32 (literal -> FLOAT .)
    EQUAL           reduce using rule 32 (literal -> FLOAT .)
    GEQUAL          reduce using rule 32 (literal -> FLOAT .)
    GREATERT        reduce using rule 32 (literal -> FLOAT .)
    LEQUAL          reduce using rule 32 (literal -> FLOAT .)
    LESST           reduce using rule 32 (literal -> FLOAT .)
    DIVIDE          reduce using rule 32 (literal -> FLOAT .)
    TIMES           reduce using rule 32 (literal -> FLOAT .)
    MINUS           reduce using rule 32 (literal -> FLOAT .)
    PLUS            reduce using rule 32 (literal -> FLOAT .)
    )               reduce using rule 32 (literal -> FLOAT .)
    ;               reduce using rule 32 (literal -> FLOAT .)


state 20

    (33) literal -> INTEGER .
    {               reduce using rule 33 (literal -> INTEGER .)
    OR              reduce using rule 33 (literal -> INTEGER .)
    AND             reduce using rule 33 (literal -> INTEGER .)
    NEQUAL          reduce using rule 33 (literal -> INTEGER .)
    EQUAL           reduce using rule 33 (literal -> INTEGER .)
    GEQUAL          reduce using rule 33 (literal -> INTEGER .)
    GREATERT        reduce using rule 33 (literal -> INTEGER .)
    LEQUAL          reduce using rule 33 (literal -> INTEGER .)
    LESST           reduce using rule 33 (literal -> INTEGER .)
    DIVIDE          reduce using rule 33 (literal -> INTEGER .)
    TIMES           reduce using rule 33 (literal -> INTEGER .)
    MINUS           reduce using rule 33 (literal -> INTEGER .)
    PLUS            reduce using rule 33 (literal -> INTEGER .)
    )               reduce using rule 33 (literal -> INTEGER .)
    ;               reduce using rule 33 (literal -> INTEGER .)


state 21

    (9) if_statement -> IF ( . expr ) { block }
    (10) if_statement -> IF ( . expr ) { block } ELSE { block }
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 38
    literal                        shift and go to state 14

state 22

    (14) assign_statement -> IDENTIFIER ASSIGN . expr ;
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 39
    literal                        shift and go to state 14

state 23

    (12) var_declaration -> TYPE IDENTIFIER . ;
    (13) var_declaration -> TYPE IDENTIFIER . ASSIGN expr ;
    ;               shift and go to state 40
    ASSIGN          shift and go to state 41


state 24

    (11) while_statement -> WHILE expr { . block }
    (1) block -> .
    (2) block -> . statements
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . assign_statement
    (8) statement -> . var_declaration
    (11) while_statement -> . WHILE expr { block }
    (9) if_statement -> . IF ( expr ) { block }
    (10) if_statement -> . IF ( expr ) { block } ELSE { block }
    (14) assign_statement -> . IDENTIFIER ASSIGN expr ;
    (12) var_declaration -> . TYPE IDENTIFIER ;
    (13) var_declaration -> . TYPE IDENTIFIER ASSIGN expr ;
    }               reduce using rule 1 (block -> .)
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    TYPE            shift and go to state 11

    block                          shift and go to state 42
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    while_statement                shift and go to state 4
    if_statement                   shift and go to state 5
    assign_statement               shift and go to state 6
    var_declaration                shift and go to state 7

state 25

    (18) expr -> expr OR . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 43
    literal                        shift and go to state 14

state 26

    (19) expr -> expr AND . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 44
    literal                        shift and go to state 14

state 27

    (20) expr -> expr NEQUAL . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 45
    literal                        shift and go to state 14

state 28

    (21) expr -> expr EQUAL . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 46
    literal                        shift and go to state 14

state 29

    (22) expr -> expr GEQUAL . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 47
    literal                        shift and go to state 14

state 30

    (23) expr -> expr GREATERT . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 48
    literal                        shift and go to state 14

state 31

    (24) expr -> expr LEQUAL . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 49
    literal                        shift and go to state 14

state 32

    (25) expr -> expr LESST . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 50
    literal                        shift and go to state 14

state 33

    (26) expr -> expr DIVIDE . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 51
    literal                        shift and go to state 14

state 34

    (27) expr -> expr TIMES . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 52
    literal                        shift and go to state 14

state 35

    (28) expr -> expr MINUS . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 53
    literal                        shift and go to state 14

state 36

    (29) expr -> expr PLUS . expr
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 54
    literal                        shift and go to state 14

state 37

    (17) expr -> ( expr . )
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    )               shift and go to state 55
    OR              shift and go to state 25
    AND             shift and go to state 26
    NEQUAL          shift and go to state 27
    EQUAL           shift and go to state 28
    GEQUAL          shift and go to state 29
    GREATERT        shift and go to state 30
    LEQUAL          shift and go to state 31
    LESST           shift and go to state 32
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 38

    (9) if_statement -> IF ( expr . ) { block }
    (10) if_statement -> IF ( expr . ) { block } ELSE { block }
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    )               shift and go to state 56
    OR              shift and go to state 25
    AND             shift and go to state 26
    NEQUAL          shift and go to state 27
    EQUAL           shift and go to state 28
    GEQUAL          shift and go to state 29
    GREATERT        shift and go to state 30
    LEQUAL          shift and go to state 31
    LESST           shift and go to state 32
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 39

    (14) assign_statement -> IDENTIFIER ASSIGN expr . ;
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    ;               shift and go to state 57
    OR              shift and go to state 25
    AND             shift and go to state 26
    NEQUAL          shift and go to state 27
    EQUAL           shift and go to state 28
    GEQUAL          shift and go to state 29
    GREATERT        shift and go to state 30
    LEQUAL          shift and go to state 31
    LESST           shift and go to state 32
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 40

    (12) var_declaration -> TYPE IDENTIFIER ; .
    WHILE           reduce using rule 12 (var_declaration -> TYPE IDENTIFIER ; .)
    IF              reduce using rule 12 (var_declaration -> TYPE IDENTIFIER ; .)
    IDENTIFIER      reduce using rule 12 (var_declaration -> TYPE IDENTIFIER ; .)
    TYPE            reduce using rule 12 (var_declaration -> TYPE IDENTIFIER ; .)
    $end            reduce using rule 12 (var_declaration -> TYPE IDENTIFIER ; .)
    }               reduce using rule 12 (var_declaration -> TYPE IDENTIFIER ; .)


state 41

    (13) var_declaration -> TYPE IDENTIFIER ASSIGN . expr ;
    (15) expr -> . literal
    (16) expr -> . IDENTIFIER
    (17) expr -> . ( expr )
    (18) expr -> . expr OR expr
    (19) expr -> . expr AND expr
    (20) expr -> . expr NEQUAL expr
    (21) expr -> . expr EQUAL expr
    (22) expr -> . expr GEQUAL expr
    (23) expr -> . expr GREATERT expr
    (24) expr -> . expr LEQUAL expr
    (25) expr -> . expr LESST expr
    (26) expr -> . expr DIVIDE expr
    (27) expr -> . expr TIMES expr
    (28) expr -> . expr MINUS expr
    (29) expr -> . expr PLUS expr
    (30) literal -> . BOOLEAN
    (31) literal -> . STRING
    (32) literal -> . FLOAT
    (33) literal -> . INTEGER
    IDENTIFIER      shift and go to state 15
    (               shift and go to state 16
    BOOLEAN         shift and go to state 17
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INTEGER         shift and go to state 20

    expr                           shift and go to state 58
    literal                        shift and go to state 14

state 42

    (11) while_statement -> WHILE expr { block . }
    }               shift and go to state 59


state 43

    (18) expr -> expr OR expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for GEQUAL resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LEQUAL resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    {               reduce using rule 18 (expr -> expr OR expr .)
    )               reduce using rule 18 (expr -> expr OR expr .)
    ;               reduce using rule 18 (expr -> expr OR expr .)
    OR              shift and go to state 25
    AND             shift and go to state 26
    NEQUAL          shift and go to state 27
    EQUAL           shift and go to state 28
    GEQUAL          shift and go to state 29
    GREATERT        shift and go to state 30
    LEQUAL          shift and go to state 31
    LESST           shift and go to state 32
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 44

    (19) expr -> expr AND expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for GEQUAL resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LEQUAL resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    {               reduce using rule 19 (expr -> expr AND expr .)
    )               reduce using rule 19 (expr -> expr AND expr .)
    ;               reduce using rule 19 (expr -> expr AND expr .)
    OR              shift and go to state 25
    AND             shift and go to state 26
    NEQUAL          shift and go to state 27
    EQUAL           shift and go to state 28
    GEQUAL          shift and go to state 29
    GREATERT        shift and go to state 30
    LEQUAL          shift and go to state 31
    LESST           shift and go to state 32
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 45

    (20) expr -> expr NEQUAL expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 20 (expr -> expr NEQUAL expr .)
    OR              reduce using rule 20 (expr -> expr NEQUAL expr .)
    AND             reduce using rule 20 (expr -> expr NEQUAL expr .)
    NEQUAL          reduce using rule 20 (expr -> expr NEQUAL expr .)
    EQUAL           reduce using rule 20 (expr -> expr NEQUAL expr .)
    GEQUAL          reduce using rule 20 (expr -> expr NEQUAL expr .)
    GREATERT        reduce using rule 20 (expr -> expr NEQUAL expr .)
    LEQUAL          reduce using rule 20 (expr -> expr NEQUAL expr .)
    LESST           reduce using rule 20 (expr -> expr NEQUAL expr .)
    )               reduce using rule 20 (expr -> expr NEQUAL expr .)
    ;               reduce using rule 20 (expr -> expr NEQUAL expr .)
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 46

    (21) expr -> expr EQUAL expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 21 (expr -> expr EQUAL expr .)
    OR              reduce using rule 21 (expr -> expr EQUAL expr .)
    AND             reduce using rule 21 (expr -> expr EQUAL expr .)
    NEQUAL          reduce using rule 21 (expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 21 (expr -> expr EQUAL expr .)
    GEQUAL          reduce using rule 21 (expr -> expr EQUAL expr .)
    GREATERT        reduce using rule 21 (expr -> expr EQUAL expr .)
    LEQUAL          reduce using rule 21 (expr -> expr EQUAL expr .)
    LESST           reduce using rule 21 (expr -> expr EQUAL expr .)
    )               reduce using rule 21 (expr -> expr EQUAL expr .)
    ;               reduce using rule 21 (expr -> expr EQUAL expr .)
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 47

    (22) expr -> expr GEQUAL expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 22 (expr -> expr GEQUAL expr .)
    OR              reduce using rule 22 (expr -> expr GEQUAL expr .)
    AND             reduce using rule 22 (expr -> expr GEQUAL expr .)
    NEQUAL          reduce using rule 22 (expr -> expr GEQUAL expr .)
    EQUAL           reduce using rule 22 (expr -> expr GEQUAL expr .)
    GEQUAL          reduce using rule 22 (expr -> expr GEQUAL expr .)
    GREATERT        reduce using rule 22 (expr -> expr GEQUAL expr .)
    LEQUAL          reduce using rule 22 (expr -> expr GEQUAL expr .)
    LESST           reduce using rule 22 (expr -> expr GEQUAL expr .)
    )               reduce using rule 22 (expr -> expr GEQUAL expr .)
    ;               reduce using rule 22 (expr -> expr GEQUAL expr .)
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 48

    (23) expr -> expr GREATERT expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 23 (expr -> expr GREATERT expr .)
    OR              reduce using rule 23 (expr -> expr GREATERT expr .)
    AND             reduce using rule 23 (expr -> expr GREATERT expr .)
    NEQUAL          reduce using rule 23 (expr -> expr GREATERT expr .)
    EQUAL           reduce using rule 23 (expr -> expr GREATERT expr .)
    GEQUAL          reduce using rule 23 (expr -> expr GREATERT expr .)
    GREATERT        reduce using rule 23 (expr -> expr GREATERT expr .)
    LEQUAL          reduce using rule 23 (expr -> expr GREATERT expr .)
    LESST           reduce using rule 23 (expr -> expr GREATERT expr .)
    )               reduce using rule 23 (expr -> expr GREATERT expr .)
    ;               reduce using rule 23 (expr -> expr GREATERT expr .)
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 49

    (24) expr -> expr LEQUAL expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 24 (expr -> expr LEQUAL expr .)
    OR              reduce using rule 24 (expr -> expr LEQUAL expr .)
    AND             reduce using rule 24 (expr -> expr LEQUAL expr .)
    NEQUAL          reduce using rule 24 (expr -> expr LEQUAL expr .)
    EQUAL           reduce using rule 24 (expr -> expr LEQUAL expr .)
    GEQUAL          reduce using rule 24 (expr -> expr LEQUAL expr .)
    GREATERT        reduce using rule 24 (expr -> expr LEQUAL expr .)
    LEQUAL          reduce using rule 24 (expr -> expr LEQUAL expr .)
    LESST           reduce using rule 24 (expr -> expr LEQUAL expr .)
    )               reduce using rule 24 (expr -> expr LEQUAL expr .)
    ;               reduce using rule 24 (expr -> expr LEQUAL expr .)
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 50

    (25) expr -> expr LESST expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 25 (expr -> expr LESST expr .)
    OR              reduce using rule 25 (expr -> expr LESST expr .)
    AND             reduce using rule 25 (expr -> expr LESST expr .)
    NEQUAL          reduce using rule 25 (expr -> expr LESST expr .)
    EQUAL           reduce using rule 25 (expr -> expr LESST expr .)
    GEQUAL          reduce using rule 25 (expr -> expr LESST expr .)
    GREATERT        reduce using rule 25 (expr -> expr LESST expr .)
    LEQUAL          reduce using rule 25 (expr -> expr LESST expr .)
    LESST           reduce using rule 25 (expr -> expr LESST expr .)
    )               reduce using rule 25 (expr -> expr LESST expr .)
    ;               reduce using rule 25 (expr -> expr LESST expr .)
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 51

    (26) expr -> expr DIVIDE expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 26 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 26 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 26 (expr -> expr DIVIDE expr .)
    NEQUAL          reduce using rule 26 (expr -> expr DIVIDE expr .)
    EQUAL           reduce using rule 26 (expr -> expr DIVIDE expr .)
    GEQUAL          reduce using rule 26 (expr -> expr DIVIDE expr .)
    GREATERT        reduce using rule 26 (expr -> expr DIVIDE expr .)
    LEQUAL          reduce using rule 26 (expr -> expr DIVIDE expr .)
    LESST           reduce using rule 26 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 26 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 26 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 26 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 26 (expr -> expr DIVIDE expr .)
    )               reduce using rule 26 (expr -> expr DIVIDE expr .)
    ;               reduce using rule 26 (expr -> expr DIVIDE expr .)


state 52

    (27) expr -> expr TIMES expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 27 (expr -> expr TIMES expr .)
    OR              reduce using rule 27 (expr -> expr TIMES expr .)
    AND             reduce using rule 27 (expr -> expr TIMES expr .)
    NEQUAL          reduce using rule 27 (expr -> expr TIMES expr .)
    EQUAL           reduce using rule 27 (expr -> expr TIMES expr .)
    GEQUAL          reduce using rule 27 (expr -> expr TIMES expr .)
    GREATERT        reduce using rule 27 (expr -> expr TIMES expr .)
    LEQUAL          reduce using rule 27 (expr -> expr TIMES expr .)
    LESST           reduce using rule 27 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 27 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 27 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 27 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 27 (expr -> expr TIMES expr .)
    )               reduce using rule 27 (expr -> expr TIMES expr .)
    ;               reduce using rule 27 (expr -> expr TIMES expr .)


state 53

    (28) expr -> expr MINUS expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 28 (expr -> expr MINUS expr .)
    OR              reduce using rule 28 (expr -> expr MINUS expr .)
    AND             reduce using rule 28 (expr -> expr MINUS expr .)
    NEQUAL          reduce using rule 28 (expr -> expr MINUS expr .)
    EQUAL           reduce using rule 28 (expr -> expr MINUS expr .)
    GEQUAL          reduce using rule 28 (expr -> expr MINUS expr .)
    GREATERT        reduce using rule 28 (expr -> expr MINUS expr .)
    LEQUAL          reduce using rule 28 (expr -> expr MINUS expr .)
    LESST           reduce using rule 28 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 28 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 28 (expr -> expr MINUS expr .)
    )               reduce using rule 28 (expr -> expr MINUS expr .)
    ;               reduce using rule 28 (expr -> expr MINUS expr .)
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34


state 54

    (29) expr -> expr PLUS expr .
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    {               reduce using rule 29 (expr -> expr PLUS expr .)
    OR              reduce using rule 29 (expr -> expr PLUS expr .)
    AND             reduce using rule 29 (expr -> expr PLUS expr .)
    NEQUAL          reduce using rule 29 (expr -> expr PLUS expr .)
    EQUAL           reduce using rule 29 (expr -> expr PLUS expr .)
    GEQUAL          reduce using rule 29 (expr -> expr PLUS expr .)
    GREATERT        reduce using rule 29 (expr -> expr PLUS expr .)
    LEQUAL          reduce using rule 29 (expr -> expr PLUS expr .)
    LESST           reduce using rule 29 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 29 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 29 (expr -> expr PLUS expr .)
    )               reduce using rule 29 (expr -> expr PLUS expr .)
    ;               reduce using rule 29 (expr -> expr PLUS expr .)
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34


state 55

    (17) expr -> ( expr ) .
    {               reduce using rule 17 (expr -> ( expr ) .)
    OR              reduce using rule 17 (expr -> ( expr ) .)
    AND             reduce using rule 17 (expr -> ( expr ) .)
    NEQUAL          reduce using rule 17 (expr -> ( expr ) .)
    EQUAL           reduce using rule 17 (expr -> ( expr ) .)
    GEQUAL          reduce using rule 17 (expr -> ( expr ) .)
    GREATERT        reduce using rule 17 (expr -> ( expr ) .)
    LEQUAL          reduce using rule 17 (expr -> ( expr ) .)
    LESST           reduce using rule 17 (expr -> ( expr ) .)
    DIVIDE          reduce using rule 17 (expr -> ( expr ) .)
    TIMES           reduce using rule 17 (expr -> ( expr ) .)
    MINUS           reduce using rule 17 (expr -> ( expr ) .)
    PLUS            reduce using rule 17 (expr -> ( expr ) .)
    )               reduce using rule 17 (expr -> ( expr ) .)
    ;               reduce using rule 17 (expr -> ( expr ) .)


state 56

    (9) if_statement -> IF ( expr ) . { block }
    (10) if_statement -> IF ( expr ) . { block } ELSE { block }
    {               shift and go to state 60


state 57

    (14) assign_statement -> IDENTIFIER ASSIGN expr ; .
    WHILE           reduce using rule 14 (assign_statement -> IDENTIFIER ASSIGN expr ; .)
    IF              reduce using rule 14 (assign_statement -> IDENTIFIER ASSIGN expr ; .)
    IDENTIFIER      reduce using rule 14 (assign_statement -> IDENTIFIER ASSIGN expr ; .)
    TYPE            reduce using rule 14 (assign_statement -> IDENTIFIER ASSIGN expr ; .)
    $end            reduce using rule 14 (assign_statement -> IDENTIFIER ASSIGN expr ; .)
    }               reduce using rule 14 (assign_statement -> IDENTIFIER ASSIGN expr ; .)


state 58

    (13) var_declaration -> TYPE IDENTIFIER ASSIGN expr . ;
    (18) expr -> expr . OR expr
    (19) expr -> expr . AND expr
    (20) expr -> expr . NEQUAL expr
    (21) expr -> expr . EQUAL expr
    (22) expr -> expr . GEQUAL expr
    (23) expr -> expr . GREATERT expr
    (24) expr -> expr . LEQUAL expr
    (25) expr -> expr . LESST expr
    (26) expr -> expr . DIVIDE expr
    (27) expr -> expr . TIMES expr
    (28) expr -> expr . MINUS expr
    (29) expr -> expr . PLUS expr
    ;               shift and go to state 61
    OR              shift and go to state 25
    AND             shift and go to state 26
    NEQUAL          shift and go to state 27
    EQUAL           shift and go to state 28
    GEQUAL          shift and go to state 29
    GREATERT        shift and go to state 30
    LEQUAL          shift and go to state 31
    LESST           shift and go to state 32
    DIVIDE          shift and go to state 33
    TIMES           shift and go to state 34
    MINUS           shift and go to state 35
    PLUS            shift and go to state 36


state 59

    (11) while_statement -> WHILE expr { block } .
    WHILE           reduce using rule 11 (while_statement -> WHILE expr { block } .)
    IF              reduce using rule 11 (while_statement -> WHILE expr { block } .)
    IDENTIFIER      reduce using rule 11 (while_statement -> WHILE expr { block } .)
    TYPE            reduce using rule 11 (while_statement -> WHILE expr { block } .)
    $end            reduce using rule 11 (while_statement -> WHILE expr { block } .)
    }               reduce using rule 11 (while_statement -> WHILE expr { block } .)


state 60

    (9) if_statement -> IF ( expr ) { . block }
    (10) if_statement -> IF ( expr ) { . block } ELSE { block }
    (1) block -> .
    (2) block -> . statements
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . assign_statement
    (8) statement -> . var_declaration
    (11) while_statement -> . WHILE expr { block }
    (9) if_statement -> . IF ( expr ) { block }
    (10) if_statement -> . IF ( expr ) { block } ELSE { block }
    (14) assign_statement -> . IDENTIFIER ASSIGN expr ;
    (12) var_declaration -> . TYPE IDENTIFIER ;
    (13) var_declaration -> . TYPE IDENTIFIER ASSIGN expr ;
    }               reduce using rule 1 (block -> .)
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    TYPE            shift and go to state 11

    block                          shift and go to state 62
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    while_statement                shift and go to state 4
    if_statement                   shift and go to state 5
    assign_statement               shift and go to state 6
    var_declaration                shift and go to state 7

state 61

    (13) var_declaration -> TYPE IDENTIFIER ASSIGN expr ; .
    WHILE           reduce using rule 13 (var_declaration -> TYPE IDENTIFIER ASSIGN expr ; .)
    IF              reduce using rule 13 (var_declaration -> TYPE IDENTIFIER ASSIGN expr ; .)
    IDENTIFIER      reduce using rule 13 (var_declaration -> TYPE IDENTIFIER ASSIGN expr ; .)
    TYPE            reduce using rule 13 (var_declaration -> TYPE IDENTIFIER ASSIGN expr ; .)
    $end            reduce using rule 13 (var_declaration -> TYPE IDENTIFIER ASSIGN expr ; .)
    }               reduce using rule 13 (var_declaration -> TYPE IDENTIFIER ASSIGN expr ; .)


state 62

    (9) if_statement -> IF ( expr ) { block . }
    (10) if_statement -> IF ( expr ) { block . } ELSE { block }
    }               shift and go to state 63


state 63

    (9) if_statement -> IF ( expr ) { block } .
    (10) if_statement -> IF ( expr ) { block } . ELSE { block }
    WHILE           reduce using rule 9 (if_statement -> IF ( expr ) { block } .)
    IF              reduce using rule 9 (if_statement -> IF ( expr ) { block } .)
    IDENTIFIER      reduce using rule 9 (if_statement -> IF ( expr ) { block } .)
    TYPE            reduce using rule 9 (if_statement -> IF ( expr ) { block } .)
    $end            reduce using rule 9 (if_statement -> IF ( expr ) { block } .)
    }               reduce using rule 9 (if_statement -> IF ( expr ) { block } .)
    ELSE            shift and go to state 64


state 64

    (10) if_statement -> IF ( expr ) { block } ELSE . { block }
    {               shift and go to state 65


state 65

    (10) if_statement -> IF ( expr ) { block } ELSE { . block }
    (1) block -> .
    (2) block -> . statements
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . assign_statement
    (8) statement -> . var_declaration
    (11) while_statement -> . WHILE expr { block }
    (9) if_statement -> . IF ( expr ) { block }
    (10) if_statement -> . IF ( expr ) { block } ELSE { block }
    (14) assign_statement -> . IDENTIFIER ASSIGN expr ;
    (12) var_declaration -> . TYPE IDENTIFIER ;
    (13) var_declaration -> . TYPE IDENTIFIER ASSIGN expr ;
    }               reduce using rule 1 (block -> .)
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    TYPE            shift and go to state 11

    block                          shift and go to state 66
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    while_statement                shift and go to state 4
    if_statement                   shift and go to state 5
    assign_statement               shift and go to state 6
    var_declaration                shift and go to state 7

state 66

    (10) if_statement -> IF ( expr ) { block } ELSE { block . }
    }               shift and go to state 67


state 67

    (10) if_statement -> IF ( expr ) { block } ELSE { block } .
    WHILE           reduce using rule 10 (if_statement -> IF ( expr ) { block } ELSE { block } .)
    IF              reduce using rule 10 (if_statement -> IF ( expr ) { block } ELSE { block } .)
    IDENTIFIER      reduce using rule 10 (if_statement -> IF ( expr ) { block } ELSE { block } .)
    TYPE            reduce using rule 10 (if_statement -> IF ( expr ) { block } ELSE { block } .)
    $end            reduce using rule 10 (if_statement -> IF ( expr ) { block } ELSE { block } .)
    }               reduce using rule 10 (if_statement -> IF ( expr ) { block } ELSE { block } .)


Conflicts:

shift/reduce conflict for OR in state 43 resolved as shift
shift/reduce conflict for AND in state 43 resolved as shift
shift/reduce conflict for NEQUAL in state 43 resolved as shift
shift/reduce conflict for EQUAL in state 43 resolved as shift
shift/reduce conflict for GEQUAL in state 43 resolved as shift
shift/reduce conflict for GREATERT in state 43 resolved as shift
shift/reduce conflict for LEQUAL in state 43 resolved as shift
shift/reduce conflict for LESST in state 43 resolved as shift
shift/reduce conflict for DIVIDE in state 43 resolved as shift
shift/reduce conflict for TIMES in state 43 resolved as shift
shift/reduce conflict for MINUS in state 43 resolved as shift
shift/reduce conflict for PLUS in state 43 resolved as shift
shift/reduce conflict for OR in state 44 resolved as shift
shift/reduce conflict for AND in state 44 resolved as shift
shift/reduce conflict for NEQUAL in state 44 resolved as shift
shift/reduce conflict for EQUAL in state 44 resolved as shift
shift/reduce conflict for GEQUAL in state 44 resolved as shift
shift/reduce conflict for GREATERT in state 44 resolved as shift
shift/reduce conflict for LEQUAL in state 44 resolved as shift
shift/reduce conflict for LESST in state 44 resolved as shift
shift/reduce conflict for DIVIDE in state 44 resolved as shift
shift/reduce conflict for TIMES in state 44 resolved as shift
shift/reduce conflict for MINUS in state 44 resolved as shift
shift/reduce conflict for PLUS in state 44 resolved as shift